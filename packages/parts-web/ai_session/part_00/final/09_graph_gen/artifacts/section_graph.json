{
  "graph_data": {
    "nodes": [
      {
        "id": "p1",
        "label": "OS维护核心挑战",
        "category": "Pillar",
        "references": {
          "section_ids": [
            "sec_2"
          ],
          "material_ids": [
            "chunk_00/slide_004"
          ],
          "highlight": {
            "primary_material_id": "chunk_00/slide_004",
            "primary_time_ts": "00:03:39,000",
            "primary_time_ms": 219000
          }
        },
        "parent": null,
        "summary": "在AI Agent时代，传统的操作系统（OS）维护面临四大核心挑战：补丁合入、集成测试、日常运维和内核崩溃分析。这些任务人力成本高、自动化程度低，且高度依赖专家经验，是引入AI Agent进行优化的主要动因。"
      },
      {
        "id": "p2",
        "label": "AI Agent实践案例",
        "category": "Pillar",
        "references": {
          "section_ids": [
            "sec_3",
            "sec_4"
          ],
          "material_ids": [
            "chunk_00/slide_005",
            "chunk_00/slide_006",
            "chunk_00/slide_007",
            "chunk_00/slide_008",
            "chunk_00/slide_009"
          ],
          "highlight": {
            "primary_material_id": "chunk_00/slide_005",
            "primary_time_ts": "00:08:45,000",
            "primary_time_ms": 525000
          }
        },
        "parent": null,
        "summary": "针对OS维护挑战，团队利用AI Agent技术构建了自动化解决方案。重点展示了补丁合并（Patch Merging）、集成测试和Vmcore分析三个场景的实践，通过人机协同显著提升了开发与运维效率。"
      },
      {
        "id": "p3",
        "label": "技术架构与原则",
        "category": "Pillar",
        "references": {
          "section_ids": [
            "sec_5"
          ],
          "material_ids": [
            "chunk_00/slide_010",
            "chunk_00/slide_011",
            "chunk_00/slide_012"
          ],
          "highlight": {
            "primary_material_id": "chunk_00/slide_010",
            "primary_time_ts": "00:17:01,000",
            "primary_time_ms": 1021000
          }
        },
        "parent": null,
        "summary": "分享了实践背后的技术支撑和团队开发方法论。技术上依托openEuler intelligence的分层架构，保障了交互便利与代码安全。原则上强调“人机协同”和“先打通再优化”，并引入监督Agent逐步减少人工介入。"
      },
      {
        "id": "d1_1",
        "label": "挑战一：补丁合入",
        "category": "Problem",
        "references": {
          "section_ids": [
            "sec_2"
          ],
          "material_ids": [
            "chunk_00/slide_004"
          ],
          "highlight": {
            "primary_material_id": "chunk_00/slide_004",
            "primary_time_ts": "00:04:33,000",
            "primary_time_ms": 273000
          }
        },
        "parent": "p1",
        "summary": "OS团队需频繁从社区同步成千上万的补丁，分析耗时巨大（千条补丁需80-100+小时），且有超过10%的补丁存在代码冲突，需要资深工程师人工解决，人力成本高昂。"
      },
      {
        "id": "d1_2",
        "label": "挑战二：集成测试",
        "category": "Problem",
        "references": {
          "section_ids": [
            "sec_2"
          ],
          "material_ids": [
            "chunk_00/slide_004"
          ],
          "highlight": {
            "primary_material_id": "chunk_00/slide_004",
            "primary_time_ts": "00:05:48,000",
            "primary_time_ms": 348000
          }
        },
        "parent": "p1",
        "summary": "补丁合入后需进行大规模集成测试，该过程高度依赖专家的系统测试经验，但即便投入大量资源，测试覆盖效果也有限，发现新问题的概率微乎其微。"
      },
      {
        "id": "d1_3",
        "label": "挑战三：日常巡检与运维",
        "category": "Problem",
        "references": {
          "section_ids": [
            "sec_2"
          ],
          "material_ids": [
            "chunk_00/slide_004"
          ],
          "highlight": {
            "primary_material_id": "chunk_00/slide_004",
            "primary_time_ts": "00:06:30,000",
            "primary_time_ms": 390000
          }
        },
        "parent": "p1",
        "summary": "维护上百套自动化设备时，日常巡检工作产生大量低效环节：超过15%的Bug报告无效，30%以上的问题重复上报，运维人员几乎100%在进行重复劳动。"
      },
      {
        "id": "d1_4",
        "label": "挑战四：Vmcore分析",
        "category": "Problem",
        "references": {
          "section_ids": [
            "sec_2"
          ],
          "material_ids": [
            "chunk_00/slide_004"
          ],
          "highlight": {
            "primary_material_id": "chunk_00/slide_004",
            "primary_time_ts": "00:07:50,000",
            "primary_time_ms": 470000
          }
        },
        "parent": "p1",
        "summary": "Vmcore分析是OS维护中最艰巨的任务，技术门槛极高，需资深内核专家介入，问题定位和修复周期长，且过程几乎完全依赖人工经验，自动化程度极低。"
      },
      {
        "id": "d2_1",
        "label": "实践一：自动化补丁合并",
        "category": "Technology",
        "references": {
          "section_ids": [
            "sec_3"
          ],
          "material_ids": [
            "chunk_00/slide_005",
            "chunk_00/slide_006"
          ],
          "highlight": {
            "primary_material_id": "chunk_00/slide_006",
            "primary_time_ts": "00:11:07,000",
            "primary_time_ms": 667000
          }
        },
        "parent": "p2",
        "summary": "通过AI Agent实现补丁合并自动化。用户通过自然语言下达指令，Agent自动完成代码差异分析、生成报告、合并代码及处理冲突。核心是基于大模型的工作流，可自动编排补丁分析、代码整理等多个Agent协同工作。"
      },
      {
        "id": "d2_2",
        "label": "实践二：自动化集成测试",
        "category": "Technology",
        "references": {
          "section_ids": [
            "sec_4"
          ],
          "material_ids": [
            "chunk_00/slide_008"
          ],
          "highlight": {
            "primary_material_id": "chunk_00/slide_008",
            "primary_time_ts": "00:15:36,000",
            "primary_time_ms": 936000
          }
        },
        "parent": "p2",
        "summary": "通过工作流集成多个Agent，实现测试自动化。用例生产Agent基于commit信息生成用例，用例执行Agent负责执行，用例入库Agent进行归档，替代了传统的人工编写自动化用例工作。"
      },
      {
        "id": "d2_3",
        "label": "实践三：智能化Vmcore分析",
        "category": "Technology",
        "references": {
          "section_ids": [
            "sec_4"
          ],
          "material_ids": [
            "chunk_00/slide_009"
          ],
          "highlight": {
            "primary_material_id": "chunk_00/slide_009",
            "primary_time_ts": "00:16:12,000",
            "primary_time_ms": 972000
          }
        },
        "parent": "p2",
        "summary": "在Vmcore分析工具中集成多个专用Agent，进行堆栈遍历、寄存器解析、死锁分析等智能检测。由一个“研判Agent”综合所有结果，给出故障原因和解决方案建议，实现高效的人机协同诊断。"
      },
      {
        "id": "d2_4",
        "label": "关键成果：效率与准确率",
        "category": "Result",
        "references": {
          "section_ids": [
            "sec_3",
            "sec_6"
          ],
          "material_ids": [
            "chunk_00/slide_007"
          ],
          "highlight": {
            "primary_material_id": "chunk_00/slide_007",
            "primary_time_ts": "00:14:17,000",
            "primary_time_ms": 857000
          }
        },
        "parent": "p2",
        "summary": "自动化补丁合并实践取得了显著成效：分析准确率通过多模型综合稳定在90%以上；开发人员的实际投入时间从数周缩短至1-2小时，实现了数量级的效率提升。"
      },
      {
        "id": "d3_1",
        "label": "三层技术架构",
        "category": "Concept",
        "references": {
          "section_ids": [
            "sec_5"
          ],
          "material_ids": [
            "chunk_00/slide_010"
          ],
          "highlight": {
            "primary_material_id": "chunk_00/slide_010",
            "primary_time_ts": "00:17:01,000",
            "primary_time_ms": 1021000
          }
        },
        "parent": "p3",
        "summary": "整体技术架构依托openEuler intelligence，分为三层：1. 交互控制层（集成于VS Code）；2. 智能分析层（调用内网大模型API，保障代码安全）；3. 执行引擎层（负责Agent调度与MCP服务）。"
      },
      {
        "id": "d3_2",
        "label": "原则一：人机协同，先打通再优化",
        "category": "Concept",
        "references": {
          "section_ids": [
            "sec_5"
          ],
          "material_ids": [
            "chunk_00/slide_011"
          ],
          "highlight": {
            "primary_material_id": "chunk_00/slide_011",
            "primary_time_ts": "00:17:41,000",
            "primary_time_ms": 1061000
          }
        },
        "parent": "p3",
        "summary": "项目初期的核心原则是不追求完全自动化，而是先利用Agent打通完整工作流程，允许人工介入。在流程跑通后，再针对性地优化关键Agent的效率和准确率。"
      },
      {
        "id": "d3_3",
        "label": "原则二：引入监督Agent",
        "category": "Concept",
        "references": {
          "section_ids": [
            "sec_5"
          ],
          "material_ids": [
            "chunk_00/slide_012"
          ],
          "highlight": {
            "primary_material_id": "chunk_00/slide_012",
            "primary_time_ts": "00:18:33,000",
            "primary_time_ms": 1113000
          }
        },
        "parent": "p3",
        "summary": "为逐步减少人工干预，项目中引入了“监督Agent”角色。它负责自动校准和加强“执行Agent”的产出结果，通过综合多模型评估等方式提升整体自动化水平和准确性。"
      }
    ],
    "edges": [
      {
        "source": "p1",
        "target": "p2",
        "relation_type": "sequential",
        "label": "引出"
      },
      {
        "source": "p2",
        "target": "p3",
        "relation_type": "compositional",
        "label": "基于"
      },
      {
        "source": "d1_1",
        "target": "d1_2",
        "relation_type": "parallel",
        "label": "并列挑战"
      },
      {
        "source": "d1_2",
        "target": "d1_3",
        "relation_type": "parallel",
        "label": "并列挑战"
      },
      {
        "source": "d1_3",
        "target": "d1_4",
        "relation_type": "parallel",
        "label": "并列挑战"
      },
      {
        "source": "d1_1",
        "target": "d2_1",
        "relation_type": "causal",
        "label": "解决"
      },
      {
        "source": "d1_2",
        "target": "d2_2",
        "relation_type": "causal",
        "label": "解决"
      },
      {
        "source": "d1_4",
        "target": "d2_3",
        "relation_type": "causal",
        "label": "解决"
      },
      {
        "source": "d2_1",
        "target": "d2_4",
        "relation_type": "causal",
        "label": "产出"
      },
      {
        "source": "d2_1",
        "target": "d2_2",
        "relation_type": "parallel",
        "label": "并列实践"
      },
      {
        "source": "d2_2",
        "target": "d2_3",
        "relation_type": "parallel",
        "label": "并列实践"
      },
      {
        "source": "d3_1",
        "target": "d2_1",
        "relation_type": "compositional",
        "label": "支撑"
      },
      {
        "source": "d3_1",
        "target": "d2_2",
        "relation_type": "compositional",
        "label": "支撑"
      },
      {
        "source": "d3_1",
        "target": "d2_3",
        "relation_type": "compositional",
        "label": "支撑"
      },
      {
        "source": "d3_2",
        "target": "d3_3",
        "relation_type": "sequential",
        "label": "具体实现"
      }
    ]
  },
  "sections": [
    {
      "id": "sec_1",
      "index": 0,
      "title": "论坛开场与嘉宾介绍",
      "time_range": "00:00:00,500 - 00:02:03,000",
      "summary": "主持人杜海田为 openEuler Summit 2025 AI分论坛开场。他简要回顾了 openEuler 发展的三个阶段，并重点介绍了当前在 AI 领域的布局、理念及 SIG 组协同成果。最后，他隆重介绍并邀请第一位演讲嘉宾——来自深信服科技的孙政华先生上台分享。",
      "refined_script": "# openEuler Summit 2025 AI 分论坛开场致辞\n\n## 1. openEuler 发展历程\n\nopenEuler 开源六年来，其发展可划分为三个核心阶段：\n\n1.  **多样性支持**：构建支持多种计算架构的操作系统。\n2.  **全场景覆盖**：将能力扩展至服务器、云、边缘和嵌入式等所有应用场景。\n3.  **拥抱 AI**：当前阶段，将 AI 作为核心发展方向。\n\n## 2. openEuler 的 AI 战略布局\n\n自 2023 年提出 `OS for AI` 与 `AI for OS` 核心理念以来，openEuler 社区围绕以下几个方向构建 AI 能力：\n\n*   **AI 软件栈生态**：丰富和完善 AI 开发、训练、推理所需的软件栈。\n*   **推理加速**：优化操作系统层面的推理性能。\n*   **训练可用性**：提升大规模 AI 模型训练的稳定性和易用性。\n*   **整机资源利用率**：通过智能调度和管理，最大化硬件资源效率。\n*   **智能化 (Intelligence)**：将 AI 能力融入操作系统自身，实现智能运维和调优。\n\n## 3. SIG 协同与成果\n\n为推动 AI 战略落地，社区已形成多个 SIG（特别兴趣小组）协同工作的模式。\n\n*   **核心 AI 相关 SIG**：\n    *   SIG-AI\n    *   SIG-intelligence\n    *   SIG-LLM\n    *   MCP-Tools-Ecosystem SIG\n*   **协同 SIG**：\n    *   devstation SIG\n    *   编译器 SIG\n\n近期，各 SIG 协同发布了 `Intelligence BoM` 的第二个版本，并已纳入工作组。\n\n## 4. 商业落地与生态发展\n\n在技术持续演进的同时，openEuler 的 AI 能力也获得了业界合作伙伴的大力支持，并已在多个行业中出现了商业落地实践。\n\n## 5. 首场演讲嘉宾介绍\n\n接下来，将由来自深信服科技股份有限公司的研发主管孙政华先生，带来题为《基于 openEuler intelligence 组建一支 OS 开发团队》的主题分享。",
      "original_script": "女士们,先生们,大家下午好。\n欢迎大家来到操作系统峰会暨 openEuler Summit 2025 AI分论坛的现场。\n论坛现在开始。\n请允许我介绍一下自己, 我是来自 openEuler 社区 AI 方向的 SIG 组的 Maintainer, 我叫杜海田。\n本次我是作为出品人以及主持人。\n我先给大家介绍一下, 谈谈我自己对这块的一些想法。\nopenEuler 开源六年, 经历了三个阶段。第一个阶段是多样性, 第二个阶段是全场景, 第三个是 AI。现在我们正处于第三个阶段。\n从 openEuler 2023年提出 OS for AI 以及 AI for OS 这个理念以来, 一直围绕 AI 软件栈的生态、推理加速、训练的可用性、整机资源利用率、智能化几个方向构建能力。\n目前已经有四个 SIG 组, SIG-AI、SIG-intelligence、SIG-LLM, 还有 MCP-Tools-Ecosystem SIG 组, 同时与 devstation SIG 组以及编译器这个 SIG 组做好了比较好的协同。\n都一起加入了这个工作组里面去。我们也看到了今天上午的 Intelligence BoM 第二个版本纳入到这个工作组里面去。\n我们在关注技术发展的同时, 也获得了各行各业的大力支持, 也看到了一些商业落地的一些实践。\n在此, 我们非常感谢关注 openEuler AI 发展的各位开发者及伙伴的到来。\n下面, 我们隆重地邀请我们第一个演讲嘉宾, 他是来自于深信服科技股份有限公司的研发主管, 孙政华先生, 给我们带来《基于 openEuler intelligence 组建一支 OS 开发团队》的分享。大家欢迎。",
      "start_ms": 500,
      "end_ms": 123000,
      "material_ids": [
        "chunk_00/slide_001",
        "chunk_00/slide_002"
      ],
      "summary_hint": "主持人杜海田为AI分论坛开场，并介绍第一位演讲嘉宾——来自深信服科技的孙政华先生及其分享主题。",
      "lead_text": "女士们,先生们,大家下午好。",
      "tail_text": "下面, 我们隆重地邀请我们第一个演讲嘉宾, 他是来自于深信服科技股份有限公司的研发主管, 孙政华先生, 给我们带来《基于 openEuler intelligence 组建一支 OS 开发团队》的分享。大家欢迎。",
      "text_span": {
        "start": 0,
        "end": 12
      }
    },
    {
      "id": "sec_2",
      "index": 1,
      "title": "AI Agent时代背景与OS维护挑战",
      "time_range": "00:02:22,500 - 00:08:43,659",
      "summary": "在AI Agent的应用元年背景下，讲者指出了操作系统（OS）维护面临的四大核心挑战。这些挑战包括：需要耗费大量人力的补丁合入（Patch Merging）与集成测试；设备日常巡检与运维中存在大量无效和重复的Bug上报；以及对专家经验依赖极高、自动化程度低的内核崩溃（Vmcore）分析。",
      "refined_script": "## AI Agent时代背景与OS维护挑战\n\n在2024年“AI Agent应用元年”的背景下，多任务、高复杂性、高不确定性的长链条任务，可以通过类似MCP（Multi-agent Collaboration Protocol）的协议，拆解给不同专家角色的Agent协同完成。基于此，我们团队与openEuler intelligence团队合作，将AI基础设施集成到产品开发流程中，打通了包括MCP关键服务节点和Agent对接在内的开发全链路。\n\n然而，在操作系统（OS）的日常维护工作中，我们面临着四个核心挑战，这些挑战人力成本高、自动化程度低、且高度依赖专家经验。\n\n### OS维护面临的四大核心挑战\n\n#### 1. 补丁合入（Patch Merging）\n\nOS团队需要与社区保持紧密同步，频繁地进行补丁合入，这个过程存在以下痛点：\n\n*   **规模巨大**：每次需要从社区合入数千甚至上万级别的补丁或Bug Fix。\n*   **人力成本高昂**：\n    *   **分析耗时**：仅分析阶段，每千条补丁就需要一位资深工程师投入80至100小时以上（约两周工作量）。\n    *   **代码冲突**：超过10%的补丁在合入时会产生代码冲突，需要人工介入分析和解决。\n*   **服务等级协议（SLA）压力**：需承诺在14天内完成中高危漏洞的修复并推送给客户。\n\n#### 2. 集成测试\n\n补丁合入后必须进行集成测试，但其有效性面临挑战：\n\n*   **测试量级大**：测试分析的工作量与补丁规模成正比，同样是数千级别。\n*   **专家依赖性强**：内核或关键中间件的变更，需要由精通系统测试的专家来主导，门槛较高。\n*   **测试覆盖效果有限**：测试效果严重依赖专家经验。实践表明，如果一个问题在社区没有被发现，即使在内部投入大量资源进行测试，其发现概率也微乎其微，效果“聊胜于无”。\n\n#### 3. 日常巡检与运维\n\n团队维护着上百套自动化设备（物理机、虚拟机、嵌入式设备等），日常巡检和运维工作存在大量低效环节：\n\n*   **无效Bug报告**：超过15%的上报缺陷是无效或信息不全的，这不仅无助于问题解决，反而增加了开发团队的甄别负担。\n*   **重复问题占比高**：由于设备环境的相似性，约30%以上的问题是重复上报的，导致运维和开发人员在已知问题上浪费了大量精力。\n*   **工作内容高度重复**：运维人员每天的工作，如设备巡检、Bug上报、初步分析等，几乎是100%的重复劳动。\n\n#### 4. 内核崩溃（Vmcore）分析\n\n分析Vmcore以定位和修复内核Bug，是OS维护中最艰巨的任务之一。\n\n*   **技术门槛极高**：要求分析人员是资深的内核专家，并需熟悉文件系统、存储、I/O等多个子系统。否则，每个问题都需要组织多个领域的专家进行会诊。\n*   **定位修复周期长**：在线上环境中，经过大量测试后暴露的Bug通常难以复现，导致问题定位和修复的难度大、周期长。\n*   **自动化程度极低**：在引入AI能力前，Vmcore分析过程几乎完全依赖专家的个人经验和GDB等基础工具，自动化程度非常低。",
      "original_script": "各位来宾,各位老师,大家下午好。\n非常荣幸能有机会到这里, 与大家分享我们团队在操作系统与 AI 结合领域的一些关键实践和阶段性成果。\n首先, 我们回顾一下, 在2024年, 可以称为是 AI Agent 的应用元年。\n包括 MCP 协议, 其实给我们带来了非常多的改变, 比如可以将一些多任务、复杂性程度比较高、不确定性程度比较高的一些长链条的处理任务, 给它拆解成不同的专家角色, 让它们能够实现人机协同的方式, 帮我们完成工作。\n那么在这个背景之下, openEuler intelligence 团队与我们做了一些联创, 把它这一套基础设施通过集成到我们产品开发的过程中去, 然后把我们的整个的基础设施实现了一个打通。\n提供了一些 MCP 的关键的服务节点, 以及一些 Agent 的对接的方式, 然后我们的开发的流程也比较顺畅地往下跑, 包括集成到我们公司的自研的一些 Codelet 之类的开发工具里面去。\n接下来我给大家做一些简单介绍。\n在我们的 OS 团队中, 其实有几个非常大的命题, 就是关于操作系统维护的。\n首先第一个就是我们的操作系统需要非常大量地跟社区进行紧密配合, 其中一个点就是我们的 Patch Merging。\nPatch Merging 就是我们需要频繁地从社区合入一些补丁或者 Bug Fix。每次的合入规模可能是千级别, 甚至是如果我们大批量组件合入的时候, 都是成千上万的补丁分析的规模。\n每次分析, 工程师的耗时每千条补丁可能会耗时80+到100+小时, 也就是我们投入一个资深的内核开发工程师以及对应的组件开发工程师, 每个组件它的分析工作量大概就是两周以上。\n这只是单纯做分析, 还没有说代码的合入。\n然后在我们合入代码的过程中, 还会出现非常多的代码冲突报错, 这个时候就需要我们人为地介入, 做一个代码补丁的分析和合入, 这个地方可能占比在10%以上。\n最后就是还有一个关键的点, 就是我们给客户提供操作系统的时候, 还需要给客户承诺一个高危漏洞的响应周期, 就是在14天以内可能要完成中高危漏洞的修复, 并且推送到客户端。\n这是一个典型的 Patch Merging 的一个场景。\n然后第二个场景的话, 就是我们在合入代码过程中还需要做一些集成测试。\n集成测试也是一样的, 就是我们可能根据社区的合入建议, 我们需要自己自身去做一个分析和测试合入。\n第一个就是分析的量级跟补丁的规模其实是比较对应的, 那我们可能会做一些融合, 比如说按模块去区分, 但是其实并没有一个明显的降低, 也是数千级别的一次每次的合入。\n第二块就是对测试能力的要求, 其实相对来说是比较高的, 因为我们内核代码的合入或者说一些关键中间件的合入, 它需要对我们的系统测试非常非常精通, 可能是一个比较高、比较精通这里的一个测试专家。\n最终的覆盖效果, 其实我们认为, 我们从我们的实际的产出来看, 如果社区测不出来这个问题, 那我们其实自己去测, 即使是我们做了非常多的 Patch Merging 之后的一个合入的话, 它的那个测试效果其实也是聊胜于无的, 可以认为就是测试的效果并不是非常的好, 因为因为它比较依赖于我们那个测试的专家以及他的经验。\n好。\n那第三个场景的话, 就是在我们的开发运维的一个过程当中, 可能需要对我们非常多的设备去做一个实时的监控, 然后当它出现一些问题的时候, 我们需要把这些问题上报到我们的巡检平台, 或者是进行一个 Bug 的记录。\n那这个地方我们内部的操作系统团队这边维护了上百套的自动化的设备, 包括那个虚拟化部署的、物理机部署的, 以及运行到一些可能小、小规模的一些嵌入式设备之类的, 这里面搭载了上百套的一个设备在上面去。那么我们的运维人员每天就需要对这个设备进行一个定期的检查和巡检。\n如果说它出现问题的话, 那就需要记录, 然后找开发工程师去做一个分析。\n那这里的那个设备数量的话就是上百套, 然后但是出现问题的时候, 那对于这个测试专家来说, 或者说这个运维专家来说, 他需要对这些信息做初步的分析和 Bug 的上报, 这个 Bug 上报过程就会需要很多的信息的记录。那其实我们发现, 在这个他们提交的缺陷里面, 然后我们去回溯它的是否有效的一个情况来看的话, 可能有15%以上都是无效的 Bug, 或者是信息不全的一些 Bug。\n那这样的话对于我们的操作系统团队去维护这些 Bug, 或者说修复这些 Bug 来说, 它其实并没有起到正向的作用, 反而产生了非常多的无效的工作量。\n然后呢, 重复问题的占比也是非常非常高的, 就是因为非常多的设备, 它可能具备一定的相似性, 或者说它很多问题会在不同的设备上面出现。那出现这样问题的时候呢, 我们也做了一个分析, 大概是30%以上的问题都是重复性的, 也就是不是第一次首次提交的一些问题, 这里也会消耗非常多的工作量。\n每天的重复工作几乎是接近100%, 因为这个同学他天天就需要去对设备去做巡检, 然后呢去做 Bug 的上报, 去做技术分析。\n然后最后一个场景的话, 就是我们对于一些维护内核的同事可能比较熟悉的, 就是对那个 Vmcore 做一个分析, 就是去查一些内核的 Bug, 然后修复内核的 Bug。这里要求的话是非常高的, 就是对这个技术人员的要求是非常高的, 它是一个需要一个资深的内核的研发, 并且要熟悉各个内核的子系统。\n否则的话, 就是每个 Bug 就需要拉上一个整个团队的不同方向的, 比如文件存储啊, 然后呢 IO 之类的工程师去一起分析, 所以对这个专业性要求是非常高的。\n然后解决耗时的话其实也是比较高的, 因为我们经过大量测试之后发布的一个问题的话, 它相对来说比较少, 然后在这个情况出现 Bug 的话, 它的概率相对来说比较低, 然后难度就会比较高。\n修复的周期的话都会相对很长。\n但这个过程的自动化占比其实是非常非常低的, 在我们落地之前其实非常非常低的, 可以说全靠人工的经验和现有的一些 GCC、Vmcore 分析的一些工具。\n我们怎么解决的呢?",
      "start_ms": 142500,
      "end_ms": 523659,
      "material_ids": [
        "chunk_00/slide_003",
        "chunk_00/slide_004"
      ],
      "summary_hint": "讲者首先介绍了AI Agent的应用元年背景，并引出操作系统（OS）生命周期维护中的核心痛点，特别是补丁合入（Patch Merging）的巨大工作量。",
      "lead_text": "各位来宾,各位老师,大家下午好。",
      "tail_text": "我们怎么解决的呢?",
      "text_span": {
        "start": 13,
        "end": 46
      }
    },
    {
      "id": "sec_3",
      "index": 2,
      "title": "实践案例一：补丁合并（Patch Merging）",
      "time_range": "00:08:43,660 - 00:15:35,359",
      "summary": "本节以补丁合并（Patch Merging）为例，介绍了如何通过自然语言输入，让 AI Agent 自动完成内核代码的差异分析、生成报告并等待人工确认。其内部实现基于一个由大模型驱动的工作流，该工作流会自动编排补丁分析、代码整理等多个 Agent，以处理代码合并与冲突解决。该实践将原先耗时数周的分析工作缩短至一到两个小时，分析准确率达到90%以上，极大地提升了效率。",
      "refined_script": "# 实践案例一：补丁合并（Patch Merging）\n\n## 1. 背景：传统内核补丁合并的挑战\n\n在传统的内核代码维护流程中，补丁合并（Patch Merging）是一项耗时且复杂的任务。开发人员需要投入大量精力进行人工分析，详细阅读每个补丁（Patch）的提交信息（Commit）和代码上下文，以判断其价值和潜在影响。这一过程通常需要数周时间，效率低下且工作内容重复。\n\n## 2. AI Agent 驱动的自动化流程\n\n为解决上述挑战，我们引入了由 AI Agent 驱动的自动化补丁合并方案。该方案将用户从繁琐的分析工作中解放出来，整体流程如下：\n\n1.  **自然语言输入**：用户以自然语言下达指令，例如：“请拉取 Linux 主线某个指定节点的代码，并与我当前的内核版本进行对比分析。”\n\n2.  **AI 自动分析与报告生成**：系统接收指令后，AI Agent 会自动执行以下操作：\n    *   拉取指定版本的内核代码。\n    *   分析两个版本间的差异，包括 Commit 和 Patch 的详细内容。\n    *   生成一份详尽的分析报告，等待人工审核。\n\n3.  **人工审核与确认**：由于 AI 分析无法保证 100% 的准确性，此环节至关重要。开发人员需对分析报告进行校准和评估。为提高准确性，系统可调用多个不同的大模型 Agent 进行交叉分析。人工确认后，将结果反馈给系统。\n\n4.  **自动合并与冲突处理**：系统接收到确认指令后，会调用下一个 Agent 执行代码合并任务。该 Agent 会尝试将确认的补丁自动合入代码主线，并处理合并过程中出现的冲突。若自动解决冲突失败，系统会标记并交由人工处理。\n\n5.  **生成最终报告**：合并完成后，系统会生成一份最终报告，内容包括：\n    *   成功合入的补丁数量与列表。\n    *   每个补丁的合并结果详情。\n    *   对应的代码提交链接，便于归档和二次确认。\n\n通过这一自动化流程，开发人员只需在关键节点进行审核，即可将原先耗时数周的工作缩短至一到两个小时。\n\n## 3. 内部实现：基于大模型的工作流与 Agent 协同\n\n从技术实现的角度，该方案基于一个由大模型驱动的、可自动编排的 Agent 工作流。\n\n### 3.1 核心架构：工作流（Workflow）驱动\n\n工作流是整个系统的“大脑”，它基于大语言模型（LLM）构建，具备自动规划能力。其主要职责是：\n\n*   **解析自然语言**：理解用户的自然语言输入。\n*   **任务编排**：根据预设的 Agent 工具集（如补丁分析 Agent、代码整理 Agent），自动规划并编排任务执行顺序。例如，工作流可以决定先分析 I/O 栈的补丁，整理后再分析网络栈的补丁。\n*   **生成执行计划**：输出初步的任务规划，供人工确认后执行。\n\n### 3.2 关键 Agent 介绍\n\n工作流通过调度一系列功能专一的 Agent 来完成具体任务，其中最核心的三个 Agent 如下：\n\n| Agent 类型 | 功能描述 |\n| :--- | :--- |\n| **补丁分析 Agent** | 具备深度代码理解能力。结合提示词（Prompt）中定义的分析范围和 Commit 信息，识别出关键内容（如宕机、网络异常、CVE 漏洞等），并评估其影响面和严重等级（高、中、低）。 |\n| **代码整理 Agent** | 在人工确认后启动，负责将补丁自动合并（Merge）到目标代码分支。它会尝试自动解决合并冲突，并在失败时将相关链接反馈给用户进行人工介入。 |\n| **（其他）** | 系统还包含许多其他小型 Agent，共同支撑整个工作流的顺畅运行。 |\n\n## 4. 实践成果与价值\n\n该方案在内核团队的季度性代码分析与合入工作中取得了显著成效，主要体现在以下方面：\n\n*   **分析准确率**\n    *   初期使用单一模型，准确率在 75% 至 93% 之间。\n    *   通过综合多个模型进行分析，最终准确率稳定在 **90% 以上**。\n\n*   **效率提升**\n    *   **之前**：每次分析与合入工作，开发人员需投入至少一周以上的时间。\n    *   **现在**：开发人员的实际投入时间缩短至 **1 到 2 小时**，实现了数量级的效率提升。",
      "original_script": "我们先以第一个 MCP Servers 来落地我们 Patch Merging 这个, 我一个例子, 我一个一个起点来做一下简单的介绍。从用户的角度来说的话, 我们如果说以前在合代码, 以前合代码的旅程的话, 就是人工地去做大量的分析。\n把每个 patch 都做一个详细的分析, 结合它的 commit 以及代码的上下文。\n然后呢, 我们落地这个之后呢, 大概的流程就是通过用户以自然语言的方式进行输入, 比如说我需要拉取 Linux 主线上面的某个节点的一个代码, 然后跟我当前的内核主线的代码做一个对比分析。\n那么它们就会去把这两个内核之间的一个差异, commit 的一个差异以及 patch 的差异, 做一个详细的分析之后, 然后它就会输出一个分析报告。\nAgent 就会帮我们输出一个分析报告, 这个分析报告呢是可以给到我们人工去做一个校准的。因为我们其实现在并不能完全100%地相信 AI 分析的一个结果。\n很多时候它可能会出现一些误判, 有的时候我们可能会调用多个 Agent 去, 比如说不同的模型对它做一个分析, 然后我们人工需要对这个结果做一个综合性的一个评估之后, 然后呢, 做出人工确认的一个调整, 我们确认它需要合入, 或者确认它对我们的业务产生影响, 那它是有价值的, 那我们再做一个回写, 把这个结果回写到它给我们的一个报告里面去。\n然后再次把这个报告传递给它, 然后呢, 它再会调用下一个 Agent 去帮我们把这个代码的合入进行一个完成, 或者说是它会对中间出现一些冲突啊, 做一些自动的一些分析和做一个代码的合入。\n那么这样一个过程呢, 其实就让我们能够能够能够释放出来非常多精力了。\n比如说我们再输入一条命令, 就是比如说我要它分析 openEuler 24.03 SP1 现在某某 commit 到我们现在内核的一个分析之后, 那这个这个同事他就可以同时去做别的事情。\n那么等过上可能一晚上或者说是一天的时间, 那我们拿到一个分析报告之后, 这个时候再花上1到2个小时的时间去把这个代码 merge, 做一下代码 patch, 做一下分析报告的一个确认, 那这样它的工作就基本是完成了, 完成90%了。\n以前呢, 它可能是每个 patch 分析, 每个 patch 分析都是耗时两周以上的, 那现在可能1到2个小时的时间, 实际投入时间1到2个小时的时间, 那它就能完成这个工作了。\n好。\n这个视频是能播放的吗? 这个地方有一个, 有一个视频。\n没关系。\n其实那个过程的话, 那也大概讲过了, 我们就继续往下。\n那么基于那个白盒这个视角来看的话, 给大家介绍一下就是内部是怎么去实现的这个地方。\n就内部怎么通过 Agent 的方式来实现的。首先第一个的话, 我们是规范了一个工作流, 这个工作流的话就是我们人为来进行补丁分析合入的时候的一个大概的过程。\n然后呢, 这个 workflow 就是会, 会让它具备一个那个自动规划的能力, 就是也是通过大语言, 大语言模型来实现的, 大模型来实现的。为什么要要这样来方式呢? 因为我们人工输入的时候都是一些自然语言, 所以需要用到大语言模型来实现。\n然后呢, 这个 workflow 的话呢, 它的设计的话其实就是它, 我们会给它输入下面的几个我们不同的 Agent, 比如说典型的补丁分析 Agent 和代码整理 Agent, 会告诉它这些 Agent 是完成什么工作的, 然后呢, 它在这个调度过程当中, 它的这个 workflow 过程当中, 它会去自动编排, 比如说它可能要要分批做分析, 比如说它需要先挑某些模块来分析, 分析完了之后做一下整理, 然后呢, 然后呢进行下一个模块的分析, 然后再做个整理。\n它可能会自己去做这样的一个一个任务的编排, 比如说我先分析 IO 栈的, 再分析网络栈的, 什么的。\n它这样会在这个 workflow 里面, 规划里面去做一个编排。然后第二块呢就是补丁分析的这个具体的 Agent, 就是对代码理解会稍微深刻一些的一个 Agent。\n然后呢, 它也会结合我们的一个提示词, 比如说从起点是什么, 终点是什么, 然后中间可能涉及到某些 commit 信息, 然后呢, 它会去挑选这个 commit 信息里面会包含一些重点内容, 比如说它是会影响宕机的, 会影响网络异常的, 协议栈的, 什么的。那么这样的话, 它就会结合 commit 信息的内容, 然后分析出来这个的影响面是什么, 是高、中、低, 还是什么, 是宕机还是什么, 还是什么样的一些问题, 以及 CVE 之类的, 它会给出这个漏洞的严重等级。\n然后呢, 代码整理的话, 就是在我们给它确认好这个补丁需要做合入之后, 这个 Agent 的话, 它会帮我们去把代码做一个自动的 merge, 就是 merge 到我们的代码主线。\n然后呢, 比如说出现冲突的时候, 它会帮我们自动地去解决这样的一些冲突, 当然也会失败, 失败的话就会让我们再去人工确认这个地方, 然后它会把 merge 的那个链接反馈给我们, 我们去人工确认之后, 再把人工代码, 人工把代码提交上去, 然后呢, 让它去帮我们把这个代码做最终的合入。\n那这是典型的三个 Agent, 那么可能背后还有很多其实小的 Agent, 这是典型的比较关键的三个。\n整个的流程的话就是由 workflow 先做一个那个整个的任务的一个规划, 它会先输出一个基础的一个过程出来, 然后让我们做一个人工的确认。确认好之后, 它就会做一个具体的分析, 分析好之后会给我们一个反馈, 反馈完了之后, 我们会让我们给它提交一个反馈之后, 它就会做代码的补丁的整理和合入。\n然后合入完成之后, 它会给我们一个报告, 就是它合入了多少, 它合入了多少的那个补丁, 然后呢每个补丁合入的那个结果是什么样子的, 然后呢它的提交链接是什么。\n那这样的话, 你在人工就可以让你做一个记录的归档, 或者说是再进行一次确认就 OK 了。\n好。\n然后最终的话, 我们落地的一个效果大概是还是比较突出的, 对我们来说, 就是我们每个, 每个月、每个季度都会做一次定量的代码的分析, 就是跟社区去做一个代码的分析。\n因为我们需要把那个一些典型的或者说是高危的一些漏洞, 或者说是我们常用到的一些内核模块的一些文件系统啊, IO 啊, 然后呢这些模块的严重问题需要做修复。那其实对我们来说就是一个比较重复性的一个工作, 并且它的那个价值也是比较大的一个工作。\n然后分析过程也存在一些不确定性, 然后呢, 它帮我们完成之后的效果的提升的话, 大概有这么几个。一个的话就是它的分析准确率, 其实我们也做了一下回溯, 就是采用一个模型, 就是千万三的时候那个模型, 然后我们分析完了之后, 它的准确率在75%到93%。\n然后我们最后综合了几个模型的, 多个模型之后, 它的它的那个覆盖率基本能到, 基本准确率的话基本能到90%以上。然后呢, 第二块的话是效率的一个提升, 效率提升以前的话, 其实每次分析合入的话, 至少就是开发侧一周以上。\n然后呢, 在这个落地之后呢, 我们就实现了一到两个小时之内就可以完成实际的工作。\n整个的那个合入的效率其实得到了一个数量级的一个提升。",
      "start_ms": 523660,
      "end_ms": 935359,
      "material_ids": [
        "chunk_00/slide_005",
        "chunk_00/slide_006",
        "chunk_00/slide_007"
      ],
      "summary_hint": "详细介绍了第一个落地案例——补丁合并。内容涵盖了基于MCP Servers的人机协同用户旅程、Agent内部工作流的技术实现，以及将分析效率从周级提升到小时级的显著落地效果。",
      "notes": "尾句后紧跟转场词“好。”（00:15:34,359），已将 end_ts 顺延以包含该转场，确保语义完整性。",
      "lead_text": "我们先以第一个 MCP Servers 来落地我们 Patch Merging 这个, 我一个例子, 我一个一个起点来做一下简单的介绍。从用户的角度来说的话, 我们如果说以前在合代码, 以前合代码的旅程的话, 就是人工地去做大量的分析。",
      "tail_text": "整个的那个合入的效率其实得到了一个数量级的一个提升。",
      "text_span": {
        "start": 47,
        "end": 81
      }
    },
    {
      "id": "sec_4",
      "index": 3,
      "title": "实践案例二与三：集成测试及Vmcore分析",
      "time_range": "00:15:35,359 - 00:16:59,885",
      "summary": "本节介绍了两个实践案例。在集成测试中，通过 Agent 实现了基于 commit 信息的用例自动生产、执行与入库，未来将增强对代码上下文的理解。在 Vmcore 分析中，集成了多个 Agent 进行堆栈遍历、寄存器解析和死锁分析等智能检测，并由研判 Agent 综合结果给出原因和解决方案，强调人机协同。",
      "refined_script": "## 实践案例二与三：集成测试及 Vmcore 分析\n\n### 实践案例二：基于 Agent 的集成测试自动化\n\n工作流集成了多个 Agent，以自动化完成集成测试中的不同任务。\n\n**核心 Agent 及其职责：**\n\n- **用例生产 Agent**\n  - **当前实现**：基于 commit 信息自动生成测试用例。\n  - **未来规划**：增强 Agent 对代码上下文及补丁改动的理解能力，以提供更精准的测试建议。\n- **用例执行 Agent**：自动化执行生成的测试用例。\n- **用例入库 Agent**：对测试用例进行基线管理与归档。\n\n通过该方案，可有效替代以往人工编写自动化用例的工作，释放人力。\n\n### 实践案例三：基于多 Agent 的 Vmcore 智能分析\n\n在 Vmcore 分析工具中集成了多个专用 Agent，以实现智能化的故障诊断。\n\n#### 1. 智能检测与分析\n\n多个分析 Agent 协同工作，执行以下智能检测任务：\n\n- **堆栈遍历**：自动遍历崩溃时的函数调用堆栈。\n- **寄存器解析**：解析关键寄存器状态，如 RSP（栈指针）、RIP（指令指针）等。\n- **死锁分析**：检测代码栈中可能存在的典型死锁或锁问题。\n- **静态变量分析**：分析全局静态变量的状态。\n\n#### 2. 研判与人机协同\n\n分析流程强调人机协同：\n\n1.  **综合研判**：一个“研判 Agent”负责综合上述所有分析结果。\n2.  **提供结论与建议**：研判 Agent 输出对故障原因的初步判断，并提供下一步的解决方案建议。\n3.  **人工确认与迭代**：开发人员对 Agent 的分析结果和建议进行确认。基于人工反馈，Agent 可以进行下一轮的迭代分析，持续优化。",
      "original_script": "第二块的话就是那个集成测试, 它整体的工作流其实也类似, 只是说它完成的任务会不一样。 Agent 的话就是一个是用例生产, 它目前我们实现的主要还是基于 commit 信息来做用例的生产, 那我们接下来要做的一个事情其实是让它更能理解代码的上下文。 然后根据上下文以及补丁的修复的改动来产生测试建议, 目前的话还是基于 commit 信息来的。 然后用例执行的 Agent 以及用例入库的 Agent, 就是要把用例做一些基线, 以及用例的一个最终的执行, 那它也是通过自动化来完成的。让以前的我们需要人工去写自动化用例之类的这样的一些工作也释放掉了。 第三块的话就是那个 Vmcore 的一些分析, 我们在这个 Vmcore 的分析工具里面呢, 也集成了多个 Agent, 包括一些堆栈的遍历, 包括一些寄存器的解析, 比如说一些 RSP、RIP 之类的堆栈的解析, 以及那个死锁的一些分析, 比如说典型的一些代码栈可能会出现一些死锁, 或者说是一些锁, 那个全局变量的一些静态变量的分析。 它也会做一些这样的一个智能的检测。然后呢, 分析完之后呢, 我们会有一个研判, 会有一个研判 Agent, 研判 Agent 会综合上面的分析结果, 然后会告诉它你这个可能是什原因, 然后下一步的话你应该是以什么方式来解决, 给出一些建议。 然后人工确认它分析对还是不对, 以及我们给它建议是什么, 它会还会做下一次的一个分析。 主要这个过程的话还是需要强调一个人机协同。",
      "start_ms": 935359,
      "end_ms": 1019885,
      "material_ids": [
        "chunk_00/slide_008",
        "chunk_00/slide_009"
      ],
      "summary_hint": "简要介绍了另外两个实践案例：利用Agent进行集成测试与Bug修复，以及在Vmcore分析中集成多个Agent进行智能检测。",
      "lead_text": "第二块的话就是那个集成测试, 它整体的工作流其实也类似, 只是说它完成的任务会不一样。",
      "tail_text": "主要这个过程的话还是需要强调一个人机协同。",
      "text_span": {
        "start": 83,
        "end": 90
      }
    },
    {
      "id": "sec_5",
      "index": 4,
      "title": "技术架构与团队组建原则",
      "time_range": "00:17:01,000 - 00:19:04,959",
      "summary": "该项目的技术架构依托于 openEuler intelligence，分为交互控制、智能分析和执行引擎三层，以保障交互便利性与代码安全。在团队组建与开发原则上，项目初期不追求完全自动化，而是强调人机协同，目标是先打通完整流程，再优化关键Agent的效率。为此，团队引入了监督Agent角色，以自动校准和加强执行结果，从而逐步减少人工介入。",
      "refined_script": "## 技术架构与开发原则\n\n### 1. 技术架构\n\n项目整体技术架构依托于 openEuler intelligence，分为三层，旨在保障交互便利性与代码安全性。\n\n- **交互控制层 (Interaction Control Layer)**\n  - 集成于基于 VS Code 实现的 `Codelet` 代码编辑器中，提供便捷的交互界面。\n\n- **智能分析层 (Intelligent Analysis Layer)**\n  - 通过 API 调用方式，集成了公司内部部署的基座大模型平台。\n  - 该方式确保了代码数据不离开内部环境，解决了代码安全性的问题。\n\n- **执行引擎层 (Execution Engine Layer)**\n  - 负责核心任务的调度与执行，包括 Agent 的调度及 MCP (Multi-agent Control Plane) 相关服务。\n\n### 2. 开发原则与实践\n\n项目在开发过程中遵循人机协同、迭代优化的原则，不追求初期就实现完全自动化。\n\n- **原则一：先打通流程，再优化节点**\n  - **初期目标**：首要目标是利用 Agent 打通关键节点，实现完整的工作流程。此阶段允许人工协同介入，不追求每个节点的完美自动化。\n  - **迭代策略**：在完整流程跑通并能展示直观效果后，再针对性地优化关键 Agent 的效率，如提升任务准确率或识别效率。\n  - **验收标准**：初期接受 Agent 70%-80% 的成功率，剩余部分通过人工介入校准。\n\n- **原则二：引入监督机制，逐步减少人工**\n  - **引入监督 Agent (Supervisor Agent)**：项目中引入了“监督 Agent”角色，其核心职责是自动校准“执行 Agent”的产出结果。\n  - **实现方式**：通过综合评估多个模型的结果或采用其他增强策略，对执行结果进行二次加强，从而提升整体自动化水平。\n  - **最终目标**：通过监督 Agent 的不断优化，逐步减少人工介入的需求，最终实现更高程度的自动化。",
      "original_script": "然后呢, 整体的话, 我们还是依托于那个 openEuler intelligence 这套架构来做的。openEuler 这套架构呢, 其实给我们带来了还是比较多的便利性的, 比如说对于交互控制层, 我们把它直接集成到了我们的基于 VS Code 实现的一个 Codelet 的那个代码编辑器里面去。\n然后呢, 第二个是智能分析层, 我们的基座大模型可以对我们内部的一些, 内部公司内部部署的一个大模型的一些平台, 直接通过 API 调用的方式能够集成进去, 那这样的话也解决了代码安全性的一个问题。\n然后最终是一个执行引擎层, 这个引擎层的话就是刚刚说到的一些 Agent 的调度, 然后 MCP 的一些服务。\n好。\n然后呢, 我们其实认为还是有几条原则可以给大家分享一下。第一个就是我们其实现在还没有追求到一个完全自动化。\n这是我们一开始立项的时候, 我们计划的要实现多少 Agent 来完成这个工作。我们其实一开始没有希望能够实现完全的自动化, 希望的是通过人工跟它协同交互的方式来解决解决这些问题。我们的目标是先通过 Agent 来打通一些关键的节点, 但是要把整个流程实现跑通, 把整个流程跑通之后, 然后再去做一些关键节点、关键 Agent 的去做一个效率的提升, 比如说准确率的提升, 或者说它识别效率的提升。\n那这样的话, 才能够让我们的整个不断往前去迭代, 流程打通之后, 就能让大家能够看到一个直观的效果, 然后再去做点对点的去做一个优化。\n所以一开始的话, 我们并不追求每个节点都完成得非常完美, 可能它有70%、80%以上, 我们就够了, 然后呢, 再通过人工介入的方式去校准它。\n然后呢, 最终的话, 我们目前呢也引入了一个角色, 就是监督 Agent 的一个角色, 就是监督 Agent 呢, 其实希望实现的效果就是对它的一些执行 Agent 完成的一些工作去做一个自动的一个校准, 这样的话会避免我们比较多的一些, 比如说刚刚说到的一个模型它可能只有70%、80%, 那我们可能要综合多个模型, 然后再做一些监督 Agent 的方式来对这个执行 Agent 的一个结果再做一轮的一个加强, 那这样的话, 我们后面的那个人工, 人工需要介入的工作的话就会越来越少。\n这是我们大概的一些实践的案例, 感谢大家。",
      "start_ms": 1021000,
      "end_ms": 1144959,
      "material_ids": [
        "chunk_00/slide_010",
        "chunk_00/slide_011",
        "chunk_00/slide_012"
      ],
      "summary_hint": "介绍了依托openEuler intelligence的分层技术架构，并分享了组建OS开发团队的原则，强调人机协同而非完全自动化，并引入监督Agent以提升准确性。",
      "lead_text": "然后呢, 整体的话, 我们还是依托于那个 openEuler intelligence 这套架构来做的。openEuler 这套架构呢, 其实给我们带来了还是比较多的便利性的, 比如说对于交互控制层, 我们把它直接集成到了我们的基于 VS Code 实现的一个 Codelet 的那个代码编辑器里面去。",
      "tail_text": "这是我们大概的一些实践的案例, 感谢大家。",
      "text_span": {
        "start": 91,
        "end": 100
      }
    },
    {
      "id": "sec_6",
      "index": 5,
      "title": "演讲总结与致谢",
      "time_range": "00:19:15,000 - 00:20:01,210",
      "summary": "主持人总结了孙老师团队的分享，其团队利用 MCP 方式在补丁合并与自动化测试上取得了显著成果。其中，补丁覆盖效率从周级提升到小时级，准确率也从75%提升至93%，为未来的 OS 运维提供了重要思路。",
      "refined_script": "### 分享总结：基于 MCP 的补丁管理实践\n\n孙老师团队分享了其在操作系统（OS）运维领域的实践，核心是应用 MCP 方法优化补丁管理流程，并在补丁合并与自动化测试方面取得了显著成果。\n\n#### 关键成果\n\n通过引入 MCP 方法，团队在效率和准确性上取得了显著提升：\n\n- **补丁覆盖效率**：处理周期从**周级**缩短至**小时级**。\n- **准确率**：从 **75%** 提升至 **93%**。\n\n#### 结论与展望\n\n该实践为未来的操作系统运维工作提供了重要的思路和方向。社区可与该团队根据其后续规划继续合作，共同推动该技术的进一步发展与完善。",
      "original_script": "感谢孙老师的精彩分享。我们可以看到, 刚才孙老师他们那个团队里面, 一个方面已经用了这个 MCP 的方式应用在他们的那个补丁的 merge, 然后以及这个分析或者自动化测试的这个相关的方式, 已经取得了不错的成果。我们可以看到它的补丁覆盖效率, 这个数据让我很震惊的, 就是从周级到小时级这个概念。第二个准确率其实也有一个75到93的这个不同等级的提升。\n所以这个其实为我们这个后面的那个运维啊, 就是个方向, OS 的一个重要的运维方向提供了很好的思路。很欣喜也看到后面有很多的这个这个规划, 所以我们社区可以跟这个孙老师继续合作, 把这块做得更好。",
      "start_ms": 1155000,
      "end_ms": 1201210,
      "material_ids": [
        "chunk_00/slide_013",
        "chunk_00/slide_014"
      ],
      "summary_hint": "讲者结束分享，主持人总结了分享的核心亮点，特别是补丁合并效率从周级到小时级的巨大提升，以及准确率的显著提高。",
      "notes": "原定首句为上一章节讲者结束语。已根据主持人开场白（00:19:16,039）校准 start_ts，以包含掌声和过渡。",
      "lead_text": "这是我们大概的一些实践的案例, 感谢大家。",
      "tail_text": "所以这个其实为我们这个后面的那个运维啊, 就是个方向, OS 的一个重要的运维方向提供了很好的思路。很欣喜也看到后面有很多的这个这个规划, 所以我们社区可以跟这个孙老师继续合作, 把这块做得更好。",
      "text_span": {
        "start": 100,
        "end": 102
      }
    }
  ]
}